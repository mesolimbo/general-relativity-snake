<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>General Relativity Snake - Phaser Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            overflow: hidden; /* Prevent scrolling from keys */
        }
        
        /* Game Title Styling - Warped Effect */
        .game-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin-bottom: 24px;
            box-sizing: border-box;
            padding: 0 2px; 
        }

        .title-char {
            font-weight: 900;
            color: #00ff80;
            text-shadow: 0 0 5px #ff4d4f, 0 0 10px rgba(255, 77, 79, 0.7);
            text-transform: uppercase;
            line-height: 1;
            user-select: none;
        }

        /* Score Panel */
        .score-panel-top {
            display: flex;
            justify-content: space-between;
            width: 400px;
            padding: 0 5px 10px 5px; 
            color: #c9d1d9;
            font-size: 1.2rem;
            font-weight: 700;
            text-shadow: 0 0 5px #ff7875, 0 0 10px rgba(255, 77, 79, 0.5); 
        }

        /* Phaser Container */
        #phaser-game {
            width: 400px;
            height: 400px;
            box-shadow: 0 10px 30px rgba(0, 255, 128, 0.4); 
            border: 4px solid #00ff80; 
            border-radius: 12px;
            background-color: #161b22; 
            overflow: hidden;
        }

        /* Buttons */
        .start-button {
            background-color: #238636; 
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 700;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px #1c6b29; 
            user-select: none;
            cursor: pointer;
            text-align: center;
            margin-top: 20px; 
            width: 400px; 
            max-width: 100%;
        }

        .start-button:active {
            background-color: #1c6b29;
            transform: translateY(2px);
            box-shadow: 0 2px #1c6b29;
        }

        /* D-Pad (Mobile) */
        .dpad-container {
            display: none; 
            grid-template-areas: ". up ." "left center right" ". down .";
            gap: 5px;
            margin-top: 15px;
            width: 200px; 
            margin-bottom: 20px;
        }
        
        .control-button {
            background-color: #238636;
            color: white;
            border-radius: 8px;
            padding: 15px 15px;
            font-size: 1.5rem;
            line-height: 1;
            box-shadow: 0 4px #1c6b29;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }
        .control-button:active {
            background-color: #1c6b29;
            transform: translateY(2px);
            box-shadow: 0 2px #1c6b29;
        }

        .up { grid-area: up; }
        .down { grid-area: down; }
        .left { grid-area: left; }
        .right { grid-area: right; }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #161b22;
            color: #c9d1d9;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 255, 128, 0.6);
            text-align: center;
            border: 2px solid #00ff80;
        }
        .hidden {
            display: none;
        }

        @media (max-width: 600px) {
            .dpad-container { display: grid; }
            .score-panel-top, #phaser-game, .start-button, .game-title { width: 100%; max-width: 400px; }
        }
    </style>
</head>
<body>
    
    <div id="titleContainer" class="game-title-container"></div>

    <div class="score-panel-top max-w-[400px]">
        <span>Score: <span id="score">0</span></span>
        <span>High Score: <span id="highScore">0</span></span>
    </div>

    <!-- Phaser Container -->
    <div id="phaser-game"></div>

    <button id="startButton" class="start-button">START GAME</button>

    <div class="dpad-container">
        <button class="control-button up" data-direction="UP">▲</button>
        <button class="control-button left" data-direction="LEFT">◀</button>
        <div class="center"></div>
        <button class="control-button right" data-direction="RIGHT">▶</button>
        <button class="control-button down" data-direction="DOWN">▼</button>
    </div>

    <div id="gameOverModal" class="modal hidden">
        <div class="modal-content">
            <h2 class="text-3xl font-bold text-[#00ff80] mb-4">GAME OVER!</h2>
            <p class="text-xl mb-4">Your Final Score: <span id="finalScore" class="font-bold text-white">0</span></p>
            <button id="restartButton" class="start-button">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // --- Game Constants ---
        const GRID_SIZE = 20;
        const CANVAS_SIZE = 400;
        const TILE_COUNT = CANVAS_SIZE / GRID_SIZE; 
        const MOVE_INTERVAL = 150; // Snake move speed in ms

        const WARP_RADIUS_TILES = 12; 
        const WARP_MAX_PULL_PIXELS = 0.8 * GRID_SIZE; 
        const EXTENDED_GRID_TILES = 5;

        // --- Global State for UI Interaction ---
        let gameInstance = null; // Phaser Game Instance
        let highScore = parseInt(localStorage.getItem('snakeHighScore') || '0', 10);
        document.getElementById('highScore').textContent = highScore;

        // --- Math & Color Helpers ---

        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function getWarpedPixelCoordinates(pixelX, pixelY, snakeHead) {
            if (!snakeHead) return { x: pixelX, y: pixelY, pullFactor: 0 };

            const headPixelX = snakeHead.x * GRID_SIZE + GRID_SIZE / 2;
            const headPixelY = snakeHead.y * GRID_SIZE + GRID_SIZE / 2;

            const distPixels = distance(pixelX, pixelY, headPixelX, headPixelY);
            const distTiles = distPixels / GRID_SIZE;

            let warpedX = pixelX;
            let warpedY = pixelY;
            let finalPullFactor = 0;

            if (distTiles < WARP_RADIUS_TILES && distTiles > 0) {
                const normalizedDistFromHead = Math.min(1, distTiles / WARP_RADIUS_TILES); 
                finalPullFactor = 1 - Math.pow(normalizedDistFromHead, 3);

                const deltaX = headPixelX - pixelX;
                const deltaY = headPixelY - pixelY;
                const angle = Math.atan2(deltaY, deltaX); 
                const pullMagnitude = finalPullFactor * WARP_MAX_PULL_PIXELS;

                warpedX = pixelX + Math.cos(angle) * pullMagnitude;
                warpedY = pixelY + Math.sin(angle) * pullMagnitude;
            }
            return { x: warpedX, y: warpedY, pullFactor: finalPullFactor };
        }

        // Helper to convert RGB components to Phaser hex color
        function rgbToHex(r, g, b) {
            return (r << 16) | (g << 8) | b;
        }

        function getRedshiftColor(pullFactor) {
            const factor = Math.min(1, Math.max(0, pullFactor)); 
            
            const R = Math.round(0 + (255) * factor);
            const G = Math.round(255 + (77 - 255) * factor);
            const B = Math.round(128 + (79 - 128) * factor);
            
            const color = rgbToHex(R, G, B);
            const alpha = 0.1 + (0.3 * factor);
            return { color, alpha };
        }

        function getSnakeBodyColor(index, totalLength) {
            if (totalLength <= 1) return 0xffffff;

            const ratio = (index - 1) / (totalLength - 1);
            const factor = Math.min(1, Math.max(0, ratio));

            // White to Green
            const startR = 255, startG = 255, startB = 255;
            const endR = 35, endG = 134, endB = 54;

            const R = Math.round(startR + (endR - startR) * factor);
            const G = Math.round(startG + (endG - startG) * factor);
            const B = Math.round(startB + (endB - startB) * factor);

            return rgbToHex(R, G, B);
        }

        // --- Phaser Scene ---

        class MainScene extends Phaser.Scene {
            constructor() {
                super('MainScene');
            }

            create() {
                // Graphics Objects
                this.gridGraphics = this.add.graphics();
                this.snakeGraphics = this.add.graphics();
                
                // Game State
                this.snake = [];
                this.food = { x: 15, y: 15 };
                this.dx = 0;
                this.dy = 0;
                this.nextDx = 0;
                this.nextDy = 0;
                this.score = 0;
                this.isGameStarted = false;
                this.lastMoveTime = 0;

                // Input
                this.cursors = this.input.keyboard.createCursorKeys();
                this.wKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
                this.aKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
                this.sKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
                this.dKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);

                // Initial render (static)
                this.snake = [{x: 10, y: 10}];
                this.drawGame();
                
                // Listen for UI events
                // We use a global event bus or direct method calls for simplicity
                window.startGamePhaser = () => this.startGame();
                window.setDirectionPhaser = (direction) => this.handleDirectionInput(direction);
            }

            startGame() {
                this.snake = [{ x: 10, y: 10 }];
                this.dx = 1;
                this.dy = 0;
                this.nextDx = 1;
                this.nextDy = 0;
                this.score = 0;
                document.getElementById('score').textContent = '0';
                this.placeFood();
                this.isGameStarted = true;
            }

            placeFood() {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * TILE_COUNT),
                        y: Math.floor(Math.random() * TILE_COUNT)
                    };
                } while (this.snake.some(s => s.x === newFood.x && s.y === newFood.y));
                this.food = newFood;
            }

            handleDirectionInput(direction) {
                if (!this.isGameStarted) return;

                let newDx = this.dx;
                let newDy = this.dy;

                switch (direction) {
                    case 'UP': if (this.dy !== 1) { newDx = 0; newDy = -1; } break;
                    case 'DOWN': if (this.dy !== -1) { newDx = 0; newDy = 1; } break;
                    case 'LEFT': if (this.dx !== 1) { newDx = -1; newDy = 0; } break;
                    case 'RIGHT': if (this.dx !== -1) { newDx = 1; newDy = 0; } break;
                }

                // Buffer the input to next move tick to prevent rapid self-collision
                this.nextDx = newDx;
                this.nextDy = newDy;
            }

            update(time, delta) {
                // Poll Keyboard every frame for responsiveness
                if (this.isGameStarted) {
                    if (this.cursors.up.isDown || this.wKey.isDown) this.handleDirectionInput('UP');
                    else if (this.cursors.down.isDown || this.sKey.isDown) this.handleDirectionInput('DOWN');
                    else if (this.cursors.left.isDown || this.aKey.isDown) this.handleDirectionInput('LEFT');
                    else if (this.cursors.right.isDown || this.dKey.isDown) this.handleDirectionInput('RIGHT');
                }

                if (!this.isGameStarted) {
                    // Just draw the static/warp effect if game not running
                    // No need to redraw constantly if nothing moves, but for warp effect when we eventually animate it, we might.
                    // For now, static draw is fine.
                    return;
                }

                // Game Loop Logic (Tick based)
                if (time - this.lastMoveTime > MOVE_INTERVAL) {
                    this.moveSnake();
                    this.lastMoveTime = time;
                    this.drawGame();
                }
            }

            moveSnake() {
                // Apply buffered direction
                this.dx = this.nextDx;
                this.dy = this.nextDy;

                const head = { x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy };

                // Collision Checks
                if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT ||
                    this.snake.some(s => s.x === head.x && s.y === head.y)) { // Check against *current* snake before moving tail
                    
                    // Self collision logic: usually check index > 0, but since we unshift head first normally...
                    // Actually standard logic: 
                    // If next pos is in snake body (excluding tail if we are not eating), CRASH.
                    // Simplified: Just check if head hits any existing body part.
                    // Note: If we just ate, tail doesn't move, so hitting tail is possible.
                    // If we didn't eat, tail moves, so hitting current tail is safe.
                    
                    // Let's do standard check:
                    // 1. Wall Check
                    // 2. Body Check (slice(0, -1) if not eating, or full if eating... simplified: check all)
                    
                    // Simple approach: Check if head is inside current snake body. 
                    // Exception: If we don't eat, the tail will move away.
                    const hitSelf = this.snake.some((s, i) => {
                         // If we are about to eat, we grow, so tail stays. Collision is real.
                         // If not eating, tail moves.
                         if (head.x === this.food.x && head.y === this.food.y) return s.x === head.x && s.y === head.y;
                         // If moving, ignore last segment
                         if (i === this.snake.length - 1) return false;
                         return s.x === head.x && s.y === head.y;
                    });

                    if (hitSelf || head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                        this.gameOver();
                        return;
                    }
                }

                this.snake.unshift(head);

                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score++;
                    document.getElementById('score').textContent = this.score;
                    this.placeFood();
                } else {
                    this.snake.pop();
                }
            }

            gameOver() {
                this.isGameStarted = false;
                window.triggerGameOver(this.score);
            }

            drawGame() {
                const g = this.gridGraphics;
                const sg = this.snakeGraphics;

                g.clear();
                sg.clear();

                const head = this.snake[0];

                // 1. Draw Warped Grid
                g.lineStyle(1, 0x00ff80, 1); // Default, will be overridden by redshift

                const step = GRID_SIZE / 4;
                const minTile = -EXTENDED_GRID_TILES;
                const maxTile = TILE_COUNT + EXTENDED_GRID_TILES;

                // Helper to draw line segments
                const drawWarpedLine = (x1, y1, x2, y2) => {
                    const p1 = getWarpedPixelCoordinates(x1, y1, head);
                    const p2 = getWarpedPixelCoordinates(x2, y2, head);
                    
                    const avgPull = (p1.pullFactor + p2.pullFactor) / 2;
                    const style = getRedshiftColor(avgPull);
                    
                    g.lineStyle(1, style.color, style.alpha);
                    g.beginPath();
                    g.moveTo(p1.x, p1.y);
                    g.lineTo(p2.x, p2.y);
                    g.strokePath();
                };

                // Vertical Lines
                for (let xTile = minTile; xTile <= maxTile; xTile++) {
                    const startX = xTile * GRID_SIZE;
                    for (let y = minTile * GRID_SIZE; y < maxTile * GRID_SIZE; y += step) {
                        drawWarpedLine(startX, y, startX, y + step);
                    }
                }

                // Horizontal Lines
                for (let yTile = minTile; yTile <= maxTile; yTile++) {
                    const startY = yTile * GRID_SIZE;
                    for (let x = minTile * GRID_SIZE; x < maxTile * GRID_SIZE; x += step) {
                        drawWarpedLine(x, startY, x + step, startY);
                    }
                }

                // 2. Draw Food
                const foodPx = this.food.x * GRID_SIZE + GRID_SIZE/2;
                const foodPy = this.food.y * GRID_SIZE + GRID_SIZE/2;
                const wFood = getWarpedPixelCoordinates(foodPx, foodPy, head);
                
                const minFoodScale = 0.4;
                const foodScale = 1.0 - (wFood.pullFactor * (1.0 - minFoodScale));
                const foodRadius = (GRID_SIZE / 2 * 0.8) * foodScale;

                sg.lineStyle(1, 0xff7875, 1);
                sg.fillStyle(0xff4d4f, 1);
                sg.fillCircle(wFood.x, wFood.y, foodRadius);
                sg.strokeCircle(wFood.x, wFood.y, foodRadius);

                // 3. Draw Snake
                this.snake.forEach((segment, index) => {
                    const startX = segment.x * GRID_SIZE;
                    const startY = segment.y * GRID_SIZE;

                    if (index === 0) {
                        // HEAD - Small Square
                        const centerX = startX + GRID_SIZE/2;
                        const centerY = startY + GRID_SIZE/2;
                        const wCenter = getWarpedPixelCoordinates(centerX, centerY, head);
                        const headSize = GRID_SIZE * 0.4;
                        
                        // Glow effect (manual loop for layered alpha)
                        sg.fillStyle(0xffffff, 0.3);
                        sg.fillRect(wCenter.x - headSize/2 - 2, wCenter.y - headSize/2 - 2, headSize + 4, headSize + 4);

                        sg.fillStyle(0xffffff, 1);
                        sg.fillRect(wCenter.x - headSize/2, wCenter.y - headSize/2, headSize, headSize);
                    } else {
                        // BODY - Warped Polygon
                        const tl = getWarpedPixelCoordinates(startX, startY, head);
                        const tr = getWarpedPixelCoordinates(startX + GRID_SIZE, startY, head);
                        const br = getWarpedPixelCoordinates(startX + GRID_SIZE, startY + GRID_SIZE, head);
                        const bl = getWarpedPixelCoordinates(startX, startY + GRID_SIZE, head);

                        const color = getSnakeBodyColor(index, this.snake.length);

                        sg.fillStyle(color, 1);
                        sg.beginPath();
                        sg.moveTo(tl.x, tl.y);
                        sg.lineTo(tr.x, tr.y);
                        sg.lineTo(br.x, br.y);
                        sg.lineTo(bl.x, bl.y);
                        sg.closePath();
                        sg.fillPath();
                        
                        sg.lineStyle(1, 0x000000, 0.2);
                        sg.strokePath();
                    }
                });
            }
        }

        // --- Phaser Config ---
        const config = {
            type: Phaser.AUTO,
            width: 400,
            height: 400,
            parent: 'phaser-game',
            backgroundColor: '#161b22',
            scene: MainScene,
            physics: {
                default: 'arcade',
                arcade: { debug: false }
            }
        };

        // Initialize Game
        gameInstance = new Phaser.Game(config);

        // --- DOM / UI Logic ---

        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const gameOverModal = document.getElementById('gameOverModal');
        const dpadButtons = document.querySelectorAll('.dpad-container .control-button');

        // Start Game
        startButton.addEventListener('click', () => {
            startButton.style.display = 'none';
            if (window.startGamePhaser) window.startGamePhaser();
        });

        // Restart Game
        restartButton.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            if (window.startGamePhaser) window.startGamePhaser();
        });

        // Mobile Controls
        dpadButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const dir = e.target.dataset.direction;
                if (window.setDirectionPhaser) window.setDirectionPhaser(dir);
            });
        });

        // Triggered from Phaser Scene
        window.triggerGameOver = (score) => {
            startButton.style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            
            // Update High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            
            gameOverModal.classList.remove('hidden');
        };

        // Warped Title Logic (Preserved from previous version)
        function createWarpedTitle() {
            const text = "GENERAL RELATIVITY SNAKE";
            const container = document.getElementById('titleContainer');
            container.innerHTML = '';

            const len = text.length;
            const center = (len - 1) / 2;
            const minSize = 0.9; 
            const maxSize = 1.8; 

            for (let i = 0; i < len; i++) {
                const char = text[i];
                const span = document.createElement('span');
                
                if (char === ' ') {
                    span.style.width = '0.3rem'; 
                    span.style.display = 'inline-block';
                } else {
                    span.textContent = char;
                    span.className = 'title-char';
                    const dist = Math.abs(i - center) / center;
                    const size = minSize + (maxSize - minSize) * Math.pow(dist, 1.3);
                    span.style.fontSize = `${size}rem`;
                }
                container.appendChild(span);
            }
        }

        window.onload = createWarpedTitle;

    </script>
</body>
</html>